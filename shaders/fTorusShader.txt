#version 300 es

precision highp float;

uniform float time;
uniform vec2 resolution;
uniform mat4 mProjInv;
uniform mat4 mViewInv;
uniform sampler2D mazeText;

out vec4 outColor;

const float pi = acos(-1.0);
const float rOuter = 0.1;
const float rInner = 0.6;
const float lineWidth = 0.1;

float sdTorus(vec3 p, float rOuter, float rInner)
{
    vec2 q = vec2(length(p.xz) - rInner, p.y);
    return length(q) - rOuter;
}

float sdSphere(vec3 p, float s)
{
    return length(p) - s;
}

float getAtan(float y, float x)
{
    float res = (-atan(y, x) + pi) * 0.5 / pi;
    return fract(res + 0.5);
}

vec3 torusColor(vec3 p)
{
    float innerAngle = getAtan(p.x, p.z);

    vec3 newAxis = normalize(vec3(p.x, 0.0, p.z));
    vec3 orbitPos = newAxis * rInner;

    vec3 dv = p - orbitPos;
    
    float outerAngle = getAtan(p.y, dot(dv, newAxis));
    
    //innerAngle *= 10.0;
    //innerAngle = mod(innerAngle + 0.25, 10.0);

    //float c1 = texture(mazeText, vec2(innerAngle, 0.0)).r;
    float c1;
    float c2 = 1.0;

    c1 = fract(innerAngle * 60.0);
    c1 = step(lineWidth, c1);

    return vec3(c1);
}

vec3 sBasePos = vec3(0, 0, 0);

float map(vec3 p)
{
    vec3 sPos = sBasePos;

    return sdTorus(p - sPos, rOuter, rInner);
}

const float eps = 0.01;

void main()
{
    vec2 uv = (gl_FragCoord.xy * 2.0 - resolution) / resolution;

    vec4 rayClip = mProjInv * vec4(uv.x, uv.y, -1.0, 1.0);
    rayClip.z = -1.0;
    rayClip.w = 0.0;
    rayClip = mViewInv * rayClip;

    vec3 ro = (mViewInv * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec3 rd = normalize(rayClip.xyz);
    vec3 pos;
    float t = 0.0;
    float h;
    for(int i = 0; i < 64; ++i)
    {
        pos = ro + t * rd;
        h = map(pos);
        if (h <= eps * 0.01) 
            break;
        t += h;
    }

    float hitTorus = step(h, eps * 5.0);

    vec3 col = hitTorus * torusColor(pos);

    outColor = vec4(col, 1.0);
}